# 什么是服务？

在Thinkphp8中，系统服务的概念是指在执行框架的某些组件或者功能的时候需要依赖的一些基础服务，框架内置的服务只有3个：**PaginatorService**、**ValidateService**和**ModelService**。在Thinkphp8中，申明一个Service服务类需要实现两个函数：register函数（可选）和boot函数。

以**ModelService**为例：

```php
class ModelService extends Service
{
    public function boot()
    {
        Model::setDb($this->app->db);
        Model::setEvent($this->app->event);
        Model::setInvoker([$this->app, 'invoke']);
        Model::maker(function (Model $model) {...});
    }
}
```



ModelService服务只实现了boot函数，主要内容就是设置Model类的数据库管理对象、事件管理对象、回调函数管理对象等静态属性。以上Model类的静态属性都是一些全局性的属性，一般需要在控制器响应流程开始前设置。因此，很自然地想到可以把这些针对各种类的静态属性的设置操作进行封装，然后在框架启动时统一调用。这就是thinkphp8中服务这一概念的逻辑出发点。

**PaginatorService**、**ValidateService**和**ModelService**等3个内置服务的boot函数都是完成对相应类的静态属性进行设置。

那Service服务类中的register函数有什么用呢？官方文档的原文是：register方法通常用于注册系统服务，也就是将服务绑定到容器中。这句话如果不了解实现机制的话基本很难理解。下面我们看一下PaginatorService服务类的register函数：

```php
class PaginatorService extends Service
{
    public function register()
    {
        if (!$this->app->bound(Paginator::class)) {
            $this->app->bind(Paginator::class, Bootstrap::class);
        }
    }
```

PaginatorService服务类的作用是对Paginator类进行设置。Paginator类是与分页查询相关的类。可以看到，PaginatorService服务类的register函数实质上就是进行了绑定操作。注：所谓绑定，其实就是给特定的数据对象起一个比较好记的别名，然后用一个数组记录别名和原名的对应关系。

因此，Service服务类中的register函数本质就是进行绑定操作。如果不需要起别名的话，也就不需要register函数了。所以，register函数并不是必须的。











这里需要提前明确一下，在Thinkphp8的官方文档中，服务类的定义在名称上都带有`Service`后缀，例如**PaginatorService**、**ValidateService**和**ModelService**。但是在分析源码的过程中，发现这些数据结构所实现的功能并不太契合`服务`这个名称。

因此，为了便于理解代码的具体实现，下面我将对服务的概念进行更为直观的定义。服务可以理解为特定功能的函数，而**PaginatorService**、**ValidateService**和**ModelService**等称为**服务安装器类**，因为这些类的功能就是将服务（特定功能的函数）安装到Thinkphp8中。

# Thinkphp8中的服务安装器

在Thinkphp8中，服务安装器分为**系统服务安装器**和**应用服务安装器**，系统服务安装器辅助Thinkphp内置的服务的安装，应用服务安装器辅助应用级别的服务的安装。

**服务安装器需要先进行注册，然后才能启动安装服务。**

App对象（也就是IOC容器）中与服务有关的数据结构如下：

```php
class App extends Container{
    protected array $services;//存放已注册的服务安装器实例对象
    
    //存放需要依次执行的初始化器数组，注意这个数组中三个元素存在先后顺序
    protected $initializers = [
        Error::class,
        RegisterService::class,//负责系统服务安装器的注册
        BootService::class,//负责服务安装器的启动
    ];
    
    public function initialize()
    {
        // 加载全局初始化文件
        $this->load();//这个过程中，会注册appPath/service.php中定义的应用服务安装器

        // 依次启动数组$initializers中的初始化器
        foreach ($this->initializers as $initializer) {
            $this->make($initializer)->init($this);
        }
        return $this;
    }
}
```

**什么是服务安装器的注册**，服务安装器的注册其实就是将服务安装器类进行初始化（包括实例化、执行服务的register函数和bind函数），然后将实例化的服务安装器实例对象存放到App对象的\$services数组中。

需要注意的是，\$initializers数组中存放的与服务有关的初始化器有**负责注册系统服务安装器的初始化器**和**负责启动服务安装器的初始化器**。**前者**`RegisterService::class`只会注册Thinkphp8自带的框架内置系统服务安装器，并不会注册应用服务安装器（应用服务安装器在App::load函数中注册，如上面代码注释所示）。但是，**后者**`BootService::class`却会启动所有的服务安装器，包括框架系统服务安装器和应用服务安装器。

# 添加应用服务安装器

在Thinkphp8中，可以按照给定的格式自定义应用服务安装器，首先需要自定义一个服务安装器类，代码如下：

```php

namespace app;

use think\Service;

class testService extends Service
{
    //服务安装器注册时的关联操作
    public function register()
    {
        // 如果在注册服务安装器的过程中有需要执行的操作，则放在此处
        // 例如，如果需要在注册服务安装器的同时，将服务安装器实例对象绑定到容器中，则可以再次执行容器的bind函数
        // 如果该服务依赖于其他服务，还可在此进行依赖服务安装器的注册
    }

    //服务安装器的具体安装操作
    public function boot()
    {
        // 启动服务安装器，将服务安装到web应用中
    }
}
```

服务安装器类必须继承Service类型（此类型为服务安装器基类），而且需要实现boot函数（register函数不是必须的）。服务安装器类定义完成后，将服务安装器类添加到appPath/service.php文件的数组中即可。

# 应用服务安装器的注册

`App:initialize()`函数会调用`App::load()`函数加载全局初始化文件，其中就会注册应用服务安装器（位于appPath/service.php文件），关键代码如下：

```php
class App extends Container{
    
    protected function load(): void{
        //注册appPath/service.php中定义的应用服务安装器
    	if (is_file($appPath . 'service.php')) {
        	$services = include $appPath . 'service.php';
        	foreach ($services as $service) {
            	$this->register($service);
        	}
    	}
	}
    
    //将服务安装器注册到IOC容器中
    public function register(Service|string $service, bool $force = false)
    {
        $registered = $this->getService($service);

        if ($registered && !$force) {
            return $registered;
        }

        //实例化服务安装器对象
        if (is_string($service)) {
            $service = new $service($this);
        }
        
        //执行服务安装器对象的register()函数
        if (method_exists($service, 'register')) {
            $service->register();
        }
        
        //执行服务安装器对象的bind()函数
        if (property_exists($service, 'bind')) {
            $this->bind($service->bind);
        }

        //将实例化的安装器对象存入IOC容器中
        $this->services[] = $service;
    }
}
```

# 系统服务安装器的注册、服务安装器的启动

load()函数执行之后，会依次完成系统服务安装器的注册和服务安装器的启动（即执行其中的init函数），系统服务安装器的注册过程关键代码如下：

```php
class RegisterService//负责系统服务安装器的注册
{

    protected $services = [
        PaginatorService::class,//数据列表分页显示的服务安装器
        ValidateService::class,//验证输入数据合法性的服务安装器
        ModelService::class,//数据库连接和设置等服务安装器
    ];

    public function init(App $app)
    {
        $file = $app->getRootPath() . 'vendor/services.php';

        $services = $this->services;

        if (is_file($file)) {
            $services = array_merge($services, include $file);
        }

        foreach ($services as $service) {
            if (class_exists($service)) {
                $app->register($service);
            }
        }
    }
}
```

服务安装器的启动过程关键代码如下：

```php
class BootService//负责服务安装器的启动
{
    public function init(App $app)
    {
        $app->boot();//该函数会依次调用执行$app->services数组中已注册的服务安装器对象的boot函数完成服务的安装
    }
}
```

# 服务的安装过程和执行过程

以Thinkphp的验证码服务为例，验证码服务默认是不包含在Thinkphp的基础框架内，需要使用think命令引入。把验证码引入Thinkphp的基础框架后，验证码类会被添加到vendor/services.php文件中，该文件存放了Thinkphp的需要安装的系统服务列表。以下是该文件的一个示例：

```php
<?php 
// This file is automatically generated at:2024-12-02 18:08:27
declare (strict_types = 1);
return array (
  0 => 'hg\\apidoc\\providers\\ThinkPHPService',
  1 => 'think\\captcha\\CaptchaService',//验证码服务类
  2 => 'think\\app\\Service',
  3 => 'think\\queue\\Service',
  4 => 'think\\worker\\Service',
);
```

下面我们看一下验证码服务类的实现文件：

```php
<?php

namespace think\captcha;

use think\Route;
use think\Service;
use think\Validate;

class CaptchaService extends Service
{
    public function boot()
    {
        Validate::maker(function ($validate) {
            $validate->extend('captcha', function ($value) {
                return captcha_check($value);
            }, ':attribute错误!');
        });

        $this->registerRoutes(function (Route $route) {
            $route->get('captcha/[:config]', "\\think\\captcha\\CaptchaController@index");
        });
    }
}
```

可以看到，该服务类没有register函数，只有boot函数。boot函数做了两件事：一是调用了Validate类的静态函数maker；而是注册了一个路由。

下面看一下Validate类的maker静态函数实现：

```php
    public static function maker(Closure $maker)
    {
        static::$maker[] = $maker;
    }

```

maker函数就是将一个闭包保存到Validate类的属性数组中，可以预见的是，该属性数据保存的就是用于验证的一些规则集合。当某个情形下需要进行某些验证时，会依次调用Validate属性数据中的验证规则。从而也就实现了验证码的验证。



